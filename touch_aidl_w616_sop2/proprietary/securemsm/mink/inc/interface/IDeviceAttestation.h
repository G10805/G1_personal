/*
 * Copyright (c) 2020-2024 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 */
/** @file  IDeviceAttestation.idl */
/**
 * IDAError provides a list of all the errors that might be returned
 * by the methods of the IAttestationReport, IAttestationBuilder, and
 * IDeviceAttestation interfaces.
 */
/** @cond */
#pragma once
// AUTOGENERATED FILE: DO NOT EDIT

#include <stdint.h>
#include "object.h"




#define IDAError_NO_MEMORY INT32_C(10)
#define IDAError_INVALID_BUFFER INT32_C(11)
#define IDAError_INVALID_CERTIFICATE INT32_C(12)
#define IDAError_MAX_APP_DATA_LIMIT_REACHED INT32_C(13)
#define IDAError_INVALID_SECURITY_LEVEL INT32_C(14)
#define IDAError_INVALID_ATTESTATION_CONTEXT INT32_C(15)
#define IDAError_INVALID_SIGNING_KEY INT32_C(16)
#define IDAError_INVALID_NONCE INT32_C(17)
#define IDAError_INVALID_REPORT_OFFSET INT32_C(18)
#define IDAError_ATTESTATION_REPORT_FAILURE INT32_C(19)
#define IDAError_WARM_UP_FAILURE INT32_C(20)
#define IDAError_INVALID_PARAMS_CBOR INT32_C(21)
#define IDAError_ADDON_CREDENTIALS_REPORT_NOT_SET INT32_C(22)
#define IDAError_ADDON_QTEE_REPORT_NOT_SET INT32_C(23)
#define IDAError_NOT_ALLOWED INT32_C(24)


static inline int32_t
IDAError_release(Object self)
{
    return Object_invoke(self, Object_OP_release, 0, 0);
}

static inline int32_t
IDAError_retain(Object self)
{
    return Object_invoke(self, Object_OP_retain, 0, 0);
}





#define IAttestationReport_OP_getSize 0
#define IAttestationReport_OP_getBytes 1

static inline int32_t
IAttestationReport_release(Object self)
{
    return Object_invoke(self, Object_OP_release, 0, 0);
}

static inline int32_t
IAttestationReport_retain(Object self)
{
    return Object_invoke(self, Object_OP_retain, 0, 0);
}

/*
*
*   Gets the full size of the signed and encrypted attestation.
*
*   @param[out] attestationReportSize    Size of the attestation report.
*
*   @return
*   Object_OK on success.
* 
*/
static inline int32_t IAttestationReport_getSize(Object self, uint64_t *attestationReportSize_ptr)
{
    ObjectArg a[] = {
        {.b = (ObjectBuf) { attestationReportSize_ptr, sizeof(uint64_t) } },
    };
        
    int32_t result = Object_invoke(self, IAttestationReport_OP_getSize, a, ObjectCounts_pack(0, 1, 0, 0));
    
    return result;
}

/*
*
*   Gets the bytes in the attestation.
*
*   @param[in]  offset         Attestation offset.
*   @param[out] attestation    Attestation buffer.
*
*   @detdesc
*   Typical use is to get the size and then call this in a loop with
*   a 4KB buffer incrementing the offset by the number of bytes returned
*   until all the bytes have been fetched.
*   @par
*   The caller should keep track of the bytes fetched to know when they
*   have got them all.  There is no "end of file" return code.
*   @par
*   A buffer larger than 4KB may be used with some implementations. If
*   the buffer is too large for the underlying IPC mechanism, then an
*   error will be returned.
*   @par
*   An error will be returned if offset is not in the range of 0 and the
*   size of the attestation.
*   @par
*   The attestation is an encrypted data blob. There is no use for part of a
*   attestation because it cannot be decrypted; therefore, the
*   full attestation must be fetched.
*
*   @return
*   Object_OK on success.
* 
*/
static inline int32_t IAttestationReport_getBytes(Object self, uint64_t offset_val, void *attestation_ptr, size_t attestation_len, size_t *attestation_lenout)
{
    ObjectArg a[] = {
        {.b = (ObjectBuf) { &offset_val, sizeof(uint64_t) } },
        {.b = (ObjectBuf) { attestation_ptr, attestation_len * sizeof(uint8_t) } },
    };
        
    int32_t result = Object_invoke(self, IAttestationReport_OP_getBytes, a, ObjectCounts_pack(1, 1, 0, 0));
    *attestation_lenout = a[1].b.size / sizeof(uint8_t);
        
    return result;
}



#define IAttestationBuilder_SECURITY_LEVEL_UNRESTRICTED UINT32_C(1)
#define IAttestationBuilder_SECURITY_LEVEL_RESTRICTED UINT32_C(2)
#define IAttestationBuilder_SECURITY_LEVEL_SECURERESTRICTED UINT32_C(3)
#define IAttestationBuilder_SECURITY_LEVEL_HARDWARE UINT32_C(4)
#define IAttestationBuilder_ATTESTATION_CONTEXT_GENERIC UINT32_C(1)
#define IAttestationBuilder_ATTESTATION_CONTEXT_REGISTRATION UINT32_C(2)
#define IAttestationBuilder_ATTESTATION_CONTEXT_PROVISIONING UINT32_C(3)
#define IAttestationBuilder_ATTESTATION_CONTEXT_CERT_ISSUANCE UINT32_C(4)
#define IAttestationBuilder_ATTESTATION_CONTEXT_PROOF_OF_POSSESSION UINT32_C(5)
#define IAttestationBuilder_ATTESTATION_CONTEXT_LICENSING UINT32_C(6)
#define IAttestationBuilder_OPT_ADDON_NONE UINT64_C(0x0000000000000000)
#define IAttestationBuilder_OPT_ADDON_LOCATION UINT64_C(0x0000000000000001)
#define IAttestationBuilder_OPT_ADDON_RTIC_LEGACY UINT64_C(0x0000000000000002)
#define IAttestationBuilder_OPT_ADDON_TRUSTEDTIME UINT64_C(0x0000000000000004)
#define IAttestationBuilder_OPT_ADDON_CONNSEC_CSR UINT64_C(0x0000000000000008)
#define IAttestationBuilder_OPT_ADDON_TMEHW UINT64_C(0x0000000000000010)
#define IAttestationBuilder_OPT_ADDON_QRKS_WITH_BASIC_INTEGRITY UINT64_C(0x0000000000000020)
#define IAttestationBuilder_OPT_ADDON_QRKS_WITH_KP_INCIDENT UINT64_C(0x0000000000000040)
#define IAttestationBuilder_OPT_ADDON_PERIPHERAL UINT64_C(0x0000000000000080)
#define IAttestationBuilder_OPT_ADDON_CONNSEC_CDR UINT64_C(0x0000000000000100)
#define IAttestationBuilder_OPT_ADDON_ENTITY_REPORT UINT64_C(0x0000000000000200)
#define IAttestationBuilder_OPT_ADDON_QTEE_REPORT UINT64_C(0x0000000000000400)
#define IAttestationBuilder_OPT_ADDON_CREDENTIAL_REPORT UINT64_C(0x0000000000000800)
#define IAttestationBuilder_OPT_ADDON_LEGACY_HWATTESTATION_REPORT UINT64_C(0x0000000000001000)
#define IAttestationBuilder_OPT_ADDON_HLOS_BM_REPORT UINT64_C(0x0000000000002000)
#define IAttestationBuilder_OPT_ADDON_PLATFORM_BM_REPORT UINT64_C(0x0000000000004000)
#define IAttestationBuilder_OPT_ADDON_PPID_REPORT UINT64_C(0x0000000000008000)
#define IAttestationBuilder_OPT_ADDON_NIST UINT64_C(0x0000000000010000)
#define IAttestationBuilder_OPT_ADDON_ALL UINT64_C(0xFF00000000000000)
#define IAttestationBuilder_FORMAT_EAT UINT32_C(1)
#define IAttestationBuilder_KEY_DEMO UINT32_C(1)
#define IAttestationBuilder_KEY_QDAK UINT32_C(2)


#define IAttestationBuilder_OP_clearBytes 0
#define IAttestationBuilder_OP_addBytes 1
#define IAttestationBuilder_OP_build 2
#define IAttestationBuilder_OP_setDAParams 3

static inline int32_t
IAttestationBuilder_release(Object self)
{
    return Object_invoke(self, Object_OP_release, 0, 0);
}

static inline int32_t
IAttestationBuilder_retain(Object self)
{
    return Object_invoke(self, Object_OP_retain, 0, 0);
}

/*
*
*   Clears the labeled client data in the attestation builder.
*
*   @return
*   Object_OK on success.
* 
*/
static inline int32_t IAttestationBuilder_clearBytes(Object self)
{
    return Object_invoke(self, IAttestationBuilder_OP_clearBytes, 0, 0);;
}

/*
*
*   Adds any client/user specific data as blob.
*
*   @param[in] securityLevel    One of SECURITY_LEVEL_*.
*   @param[in] label            String to tag the item. The string does not have to be null-terminated.
*   @param[in] bytes            Data bytes to be added.
*
*   @return
*   Object_OK on success.
* 
*/
static inline int32_t IAttestationBuilder_addBytes(Object self, uint32_t securityLevel_val, const int8_t *label_ptr, size_t label_len, const void *bytes_ptr, size_t bytes_len)
{
    ObjectArg a[] = {
        {.b = (ObjectBuf) { &securityLevel_val, sizeof(uint32_t) } },
        {.bi = (ObjectBufIn) { label_ptr, label_len * sizeof(int8_t) } },
        {.bi = (ObjectBufIn) { bytes_ptr, bytes_len * sizeof(uint8_t) } },
    };
        
    int32_t result = Object_invoke(self, IAttestationBuilder_OP_addBytes, a, ObjectCounts_pack(3, 0, 0, 0));
    
    return result;
}

/*
*
*   Builds the full size of the signed and encrypted attestation.
*
*   @param[in]  attestationContext    Attestation contexts.
*   @param[in]  ADDONOptions          OPT_ADDON_LOCATION, OPT_ADDON_RTIC, etc. or-ed together.
*   @param[in]  formatType            Attestation formats.
*   @param[in]  keyType               Signing key types.
*   @param[in]  nonce                 Buffer containing nonce.
*   @param[out] reportStatus          Bitmap showing which addon options were successfully fetched.
*   @param[out] attestationReport     \link IAttestationReport \endlink object containing attestation.
*
*   @return
*   Object_OK on success.
* 
*/
static inline int32_t IAttestationBuilder_build(Object self, uint32_t attestationContext_val, uint64_t ADDONOptions_val, uint32_t formatType_val, uint32_t keyType_val, const void *nonce_ptr, size_t nonce_len, uint64_t *reportStatus_ptr, Object *attestationReport)
{
    struct bi {
        uint64_t m_ADDONOptions;
        uint32_t m_attestationContext;
        uint32_t m_formatType;
        uint32_t m_keyType;
    } i;
    i.m_ADDONOptions = ADDONOptions_val;
    i.m_attestationContext = attestationContext_val;
    i.m_formatType = formatType_val;
    i.m_keyType = keyType_val;
    
    ObjectArg a[] = {
        {.b = (ObjectBuf) { &i, 20 } },
        {.bi = (ObjectBufIn) { nonce_ptr, nonce_len * sizeof(uint8_t) } },
        {.b = (ObjectBuf) { reportStatus_ptr, sizeof(uint64_t) } },
        {.o = Object_NULL },
    };
        
    int32_t result = Object_invoke(self, IAttestationBuilder_OP_build, a, ObjectCounts_pack(2, 1, 0, 1));
    *attestationReport = a[3].o;
        
    return result;
}

/*
*
*   Set DA params (token_cert + nonce)
*
*   @param[in] DAParams               Buffer containing token_cert & nonce
*
*   @return
*   Object_OK on success.
* 
*/
static inline int32_t IAttestationBuilder_setDAParams(Object self, const void *DAParams_ptr, size_t DAParams_len)
{
    ObjectArg a[] = {
        {.bi = (ObjectBufIn) { DAParams_ptr, DAParams_len * sizeof(uint8_t) } },
    };
        
    int32_t result = Object_invoke(self, IAttestationBuilder_OP_setDAParams, a, ObjectCounts_pack(1, 0, 0, 0));
    
    return result;
}



#define IDeviceAttestation_RTIC_AGE_LABEL INT32_C(-77200)
#define IDeviceAttestation_TRUSTEDTIME_AGE_LABEL INT32_C(-77250)
#define IDeviceAttestation_LOCATION_AGE_LABEL INT32_C(-77270)
#define IDeviceAttestation_CONNSEC_CELLULAR_AGE_LABEL INT32_C(-77280)


#define IDeviceAttestation_OP_start 0
#define IDeviceAttestation_OP_getWarmUpStatus 1
#define IDeviceAttestation_OP_warmUp 2

static inline int32_t
IDeviceAttestation_release(Object self)
{
    return Object_invoke(self, Object_OP_release, 0, 0);
}

static inline int32_t
IDeviceAttestation_retain(Object self)
{
    return Object_invoke(self, Object_OP_retain, 0, 0);
}

/*
*
*   Starts creating an attestation.
*
*   @param[in]  licenseCert           Buffer containing license certificate.
*   @param[out] attestationBuilder    \link IAttestationBuilder \endlink object to construct an attestation.
*
*   @detdesc The license certificate must chain up to a license root to encrypt the attestation.
*
*   @return
*   Object_OK on success.
* 
*/
static inline int32_t IDeviceAttestation_start(Object self, const void *licenseCert_ptr, size_t licenseCert_len, Object *attestationBuilder)
{
    ObjectArg a[] = {
        {.bi = (ObjectBufIn) { licenseCert_ptr, licenseCert_len * sizeof(uint8_t) } },
        {.o = Object_NULL },
    };
        
    int32_t result = Object_invoke(self, IDeviceAttestation_OP_start, a, ObjectCounts_pack(1, 0, 0, 1));
    *attestationBuilder = a[1].o;
        
    return result;
}

/*
*
*   Returns CBOR that shows the last time warming up completed for each individual optional
*   data requested by the client.
*
*   @param[out] warmUpStatus    Buffer containing warmup completion timestamps in CBOR format.
*
*   @return
*   Object_OK on success.
* 
*/
static inline int32_t IDeviceAttestation_getWarmUpStatus(Object self, void *warmUpStatus_ptr, size_t warmUpStatus_len, size_t *warmUpStatus_lenout)
{
    ObjectArg a[] = {
        {.b = (ObjectBuf) { warmUpStatus_ptr, warmUpStatus_len * sizeof(uint8_t) } },
    };
        
    int32_t result = Object_invoke(self, IDeviceAttestation_OP_getWarmUpStatus, a, ObjectCounts_pack(0, 1, 0, 0));
    *warmUpStatus_lenout = a[0].b.size / sizeof(uint8_t);
        
    return result;
}

/*
*
*   Pokes at all necessary entities to prepare the relevant data, and initiates any other
*   warmup activity that might be applicable to the passed options.
*
*   @param[in] options     Options for the warmup.
*   @param[in] timeout     Time limit for the warmup to complete.
*   @param[in] callback    IDAWarmupCallback object to call when the warmup is done.
*
*   @return
*   Object_OK on success.
* 
*/
static inline int32_t IDeviceAttestation_warmUp(Object self, uint64_t options_val, uint64_t timeout_val, Object callback)
{
    struct bi {
        uint64_t m_options;
        uint64_t m_timeout;
    } i;
    i.m_options = options_val;
    i.m_timeout = timeout_val;
    
    ObjectArg a[] = {
        {.b = (ObjectBuf) { &i, 16 } },
        {.o = callback },
    };
        
    int32_t result = Object_invoke(self, IDeviceAttestation_OP_warmUp, a, ObjectCounts_pack(1, 0, 1, 0));
    
    return result;
}

