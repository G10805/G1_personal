#pragma once
/*
 * Copyright (c) 2020-2023 Qualcomm Technologies, Inc.
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 */

/** @file  IDeviceAttestation.idl */

/**
 * IDAError provides a list of all the errors that might be returned
 * by the methods of the IAttestationReport, IAttestationBuilder, and
 * IDeviceAttestation interfaces.
 */

/** @cond */

// AUTOGENERATED FILE: DO NOT EDIT

#include <cstdint>
#include <stdint.h>
#include "object.h"
#include "proxy_base.hpp"



class IDAError;
class IIDAError {
  public:
    
    static const int32_t NO_MEMORY = INT32_C(10);
    static const int32_t INVALID_BUFFER = INT32_C(11);
    static const int32_t INVALID_CERTIFICATE = INT32_C(12);
    static const int32_t MAX_APP_DATA_LIMIT_REACHED = INT32_C(13);
    static const int32_t INVALID_SECURITY_LEVEL = INT32_C(14);
    static const int32_t INVALID_ATTESTATION_CONTEXT = INT32_C(15);
    static const int32_t INVALID_SIGNING_KEY = INT32_C(16);
    static const int32_t INVALID_NONCE = INT32_C(17);
    static const int32_t INVALID_REPORT_OFFSET = INT32_C(18);
    static const int32_t ATTESTATION_REPORT_FAILURE = INT32_C(19);
    static const int32_t WARM_UP_FAILURE = INT32_C(20);
    static const int32_t INVALID_PARAMS_CBOR = INT32_C(21);
    static const int32_t ADDON_CREDENTIALS_REPORT_NOT_SET = INT32_C(22);
    static const int32_t ADDON_QTEE_REPORT_NOT_SET = INT32_C(23);
    static const int32_t NOT_ALLOWED = INT32_C(24);
    
    virtual ~IIDAError() {}
    
  protected:
      
};

class IDAError : public IIDAError, public ProxyBase {
  public:
    IDAError() {}
    IDAError(Object impl) : ProxyBase(impl) {}
    virtual ~IDAError() {}

    
};


class IAttestationReport;
class IIAttestationReport {
  public:
    
    
    virtual ~IIAttestationReport() {}
    virtual int32_t getSize( uint64_t *attestationReportSize_ptr) = 0;
    virtual int32_t getBytes( uint64_t offset_val, void *attestation_ptr, size_t attestation_len, size_t *attestation_lenout) = 0;
    
  protected:
    static const ObjectOp OP_getSize = 0;
    static const ObjectOp OP_getBytes = 1;
      
};

class IAttestationReport : public IIAttestationReport, public ProxyBase {
  public:
    IAttestationReport() {}
    IAttestationReport(Object impl) : ProxyBase(impl) {}
    virtual ~IAttestationReport() {}

    
/*
*
*   Gets the full size of the signed and encrypted attestation.
*
*   @param[out] attestationReportSize    Size of the attestation report.
*
*   @return
*   Object_OK on success.
* 
*/
    virtual int32_t getSize( uint64_t *attestationReportSize_ptr) {
        ObjectArg a[] = {
            {.b = (ObjectBuf) { attestationReportSize_ptr, sizeof(uint64_t) } },
        };
            
        int32_t result = invoke(OP_getSize, a, ObjectCounts_pack(0, 1, 0, 0));
        if (Object_OK != result) { return result; }
        
        return result;
    }
    
/*
*
*   Gets the bytes in the attestation.
*
*   @param[in]  offset         Attestation offset.
*   @param[out] attestation    Attestation buffer.
*
*   @detdesc
*   Typical use is to get the size and then call this in a loop with
*   a 4KB buffer incrementing the offset by the number of bytes returned
*   until all the bytes have been fetched.
*   @par
*   The caller should keep track of the bytes fetched to know when they
*   have got them all.  There is no "end of file" return code.
*   @par
*   A buffer larger than 4KB may be used with some implementations. If
*   the buffer is too large for the underlying IPC mechanism, then an
*   error will be returned.
*   @par
*   An error will be returned if offset is not in the range of 0 and the
*   size of the attestation.
*   @par
*   The attestation is an encrypted data blob. There is no use for part of a
*   attestation because it cannot be decrypted; therefore, the
*   full attestation must be fetched.
*
*   @return
*   Object_OK on success.
* 
*/
    virtual int32_t getBytes( uint64_t offset_val, void *attestation_ptr, size_t attestation_len, size_t *attestation_lenout) {
        ObjectArg a[] = {
            {.b = (ObjectBuf) { &offset_val, sizeof(uint64_t) } },
            {.b = (ObjectBuf) { attestation_ptr, attestation_len * sizeof(uint8_t) } },
        };
            
        int32_t result = invoke(OP_getBytes, a, ObjectCounts_pack(1, 1, 0, 0));
        if (Object_OK != result) { return result; }
        *attestation_lenout = a[1].b.size / sizeof(uint8_t);
        
        return result;
    }
    
};


class IAttestationBuilder;
class IIAttestationBuilder {
  public:
    static const uint32_t SECURITY_LEVEL_UNRESTRICTED = UINT32_C(1);
    static const uint32_t SECURITY_LEVEL_RESTRICTED = UINT32_C(2);
    static const uint32_t SECURITY_LEVEL_SECURERESTRICTED = UINT32_C(3);
    static const uint32_t SECURITY_LEVEL_HARDWARE = UINT32_C(4);
    static const uint32_t ATTESTATION_CONTEXT_GENERIC = UINT32_C(1);
    static const uint32_t ATTESTATION_CONTEXT_REGISTRATION = UINT32_C(2);
    static const uint32_t ATTESTATION_CONTEXT_PROVISIONING = UINT32_C(3);
    static const uint32_t ATTESTATION_CONTEXT_CERT_ISSUANCE = UINT32_C(4);
    static const uint32_t ATTESTATION_CONTEXT_PROOF_OF_POSSESSION = UINT32_C(5);
    static const uint32_t ATTESTATION_CONTEXT_LICENSING = UINT32_C(6);
    static const uint64_t OPT_ADDON_NONE = UINT64_C(0x0000000000000000);
    static const uint64_t OPT_ADDON_LOCATION = UINT64_C(0x0000000000000001);
    static const uint64_t OPT_ADDON_RTIC_LEGACY = UINT64_C(0x0000000000000002);
    static const uint64_t OPT_ADDON_TRUSTEDTIME = UINT64_C(0x0000000000000004);
    static const uint64_t OPT_ADDON_CONNSEC_CSR = UINT64_C(0x0000000000000008);
    static const uint64_t OPT_ADDON_TMEHW = UINT64_C(0x0000000000000010);
    static const uint64_t OPT_ADDON_QRKS_WITH_BASIC_INTEGRITY = UINT64_C(0x0000000000000020);
    static const uint64_t OPT_ADDON_QRKS_WITH_KP_INCIDENT = UINT64_C(0x0000000000000040);
    static const uint64_t OPT_ADDON_PERIPHERAL = UINT64_C(0x0000000000000080);
    static const uint64_t OPT_ADDON_CONNSEC_CDR = UINT64_C(0x0000000000000100);
    static const uint64_t OPT_ADDON_ENTITY_REPORT = UINT64_C(0x0000000000000200);
    static const uint64_t OPT_ADDON_QTEE_REPORT = UINT64_C(0x0000000000000400);
    static const uint64_t OPT_ADDON_CREDENTIAL_REPORT = UINT64_C(0x0000000000000800);
    static const uint64_t OPT_ADDON_LEGACY_HWATTESTATION_REPORT = UINT64_C(0x0000000000001000);
    static const uint64_t OPT_ADDON_HLOS_BM_REPORT = UINT64_C(0x0000000000002000);
    static const uint64_t OPT_ADDON_PLATFORM_BM_REPORT = UINT64_C(0x0000000000004000);
    static const uint64_t OPT_ADDON_PPID_REPORT = UINT64_C(0x0000000000008000);
    static const uint64_t OPT_ADDON_NIST = UINT64_C(0x0000000000010000);
    static const uint64_t OPT_ADDON_ALL = UINT64_C(0xFF00000000000000);
    static const uint32_t FORMAT_EAT = UINT32_C(1);
    static const uint32_t KEY_DEMO = UINT32_C(1);
    static const uint32_t KEY_QDAK = UINT32_C(2);
    
    
    virtual ~IIAttestationBuilder() {}
    virtual int32_t clearBytes() = 0;
    virtual int32_t addBytes( uint32_t securityLevel_val, const int8_t *label_ptr, size_t label_len, const void *bytes_ptr, size_t bytes_len) = 0;
    virtual int32_t build( uint32_t attestationContext_val, uint64_t ADDONOptions_val, uint32_t formatType_val, uint32_t keyType_val, const void *nonce_ptr, size_t nonce_len, uint64_t *reportStatus_ptr, IAttestationReport &attestationReport) = 0;
    virtual int32_t setDAParams( const void *DAParams_ptr, size_t DAParams_len) = 0;
    
  protected:
    static const ObjectOp OP_clearBytes = 0;
    static const ObjectOp OP_addBytes = 1;
    static const ObjectOp OP_build = 2;
    static const ObjectOp OP_setDAParams = 3;
      
};

class IAttestationBuilder : public IIAttestationBuilder, public ProxyBase {
  public:
    IAttestationBuilder() {}
    IAttestationBuilder(Object impl) : ProxyBase(impl) {}
    virtual ~IAttestationBuilder() {}

    
/*
*
*   Clears the labeled client data in the attestation builder.
*
*   @return
*   Object_OK on success.
* 
*/
    virtual int32_t clearBytes() {
        int32_t result = invoke(OP_clearBytes, 0, 0);
        if (Object_OK != result) { return result; }
        
        return result;
    }
    
/*
*
*   Adds any client/user specific data as blob.
*
*   @param[in] securityLevel    One of SECURITY_LEVEL_*.
*   @param[in] label            String to tag the item. The string does not have to be null-terminated.
*   @param[in] bytes            Data bytes to be added.
*
*   @return
*   Object_OK on success.
* 
*/
    virtual int32_t addBytes( uint32_t securityLevel_val, const int8_t *label_ptr, size_t label_len, const void *bytes_ptr, size_t bytes_len) {
        ObjectArg a[] = {
            {.b = (ObjectBuf) { &securityLevel_val, sizeof(uint32_t) } },
            {.bi = (ObjectBufIn) { label_ptr, label_len * sizeof(int8_t) } },
            {.bi = (ObjectBufIn) { bytes_ptr, bytes_len * sizeof(uint8_t) } },
        };
            
        int32_t result = invoke(OP_addBytes, a, ObjectCounts_pack(3, 0, 0, 0));
        if (Object_OK != result) { return result; }
        
        return result;
    }
    
/*
*
*   Builds the full size of the signed and encrypted attestation.
*
*   @param[in]  attestationContext    Attestation contexts.
*   @param[in]  ADDONOptions          OPT_ADDON_LOCATION, OPT_ADDON_RTIC, etc. or-ed together.
*   @param[in]  formatType            Attestation formats.
*   @param[in]  keyType               Signing key types.
*   @param[in]  nonce                 Buffer containing nonce.
*   @param[out] reportStatus          Bitmap showing which addon options were successfully fetched.
*   @param[out] attestationReport     \link IAttestationReport \endlink object containing attestation.
*
*   @return
*   Object_OK on success.
* 
*/
    virtual int32_t build( uint32_t attestationContext_val, uint64_t ADDONOptions_val, uint32_t formatType_val, uint32_t keyType_val, const void *nonce_ptr, size_t nonce_len, uint64_t *reportStatus_ptr, IAttestationReport &attestationReport) {
        struct bi {
            uint64_t m_ADDONOptions;
            uint32_t m_attestationContext;
            uint32_t m_formatType;
            uint32_t m_keyType;
        } i;
        i.m_ADDONOptions = ADDONOptions_val;
        i.m_attestationContext = attestationContext_val;
        i.m_formatType = formatType_val;
        i.m_keyType = keyType_val;
        
        ObjectArg a[] = {
            {.b = (ObjectBuf) { &i, 20 } },
            {.bi = (ObjectBufIn) { nonce_ptr, nonce_len * sizeof(uint8_t) } },
            {.b = (ObjectBuf) { reportStatus_ptr, sizeof(uint64_t) } },
            {.o = (Object) { NULL, NULL } },
        };
            
        int32_t result = invoke(OP_build, a, ObjectCounts_pack(2, 1, 0, 1));
        if (Object_OK != result) { return result; }
        attestationReport.consume(a[3].o);
        
        return result;
    }
    
/*
*
*   Set DA params (token_cert + nonce)
*
*   @param[in] DAParams               Buffer containing token_cert & nonce
*
*   @return
*   Object_OK on success.
* 
*/
    virtual int32_t setDAParams( const void *DAParams_ptr, size_t DAParams_len) {
        ObjectArg a[] = {
            {.bi = (ObjectBufIn) { DAParams_ptr, DAParams_len * sizeof(uint8_t) } },
        };
            
        int32_t result = invoke(OP_setDAParams, a, ObjectCounts_pack(1, 0, 0, 0));
        if (Object_OK != result) { return result; }
        
        return result;
    }
    
};


class IDeviceAttestation;
class IIDeviceAttestation {
  public:
    static const int32_t RTIC_AGE_LABEL = INT32_C(-77200);
    static const int32_t TRUSTEDTIME_AGE_LABEL = INT32_C(-77250);
    static const int32_t LOCATION_AGE_LABEL = INT32_C(-77270);
    static const int32_t CONNSEC_CELLULAR_AGE_LABEL = INT32_C(-77280);
    
    
    virtual ~IIDeviceAttestation() {}
    virtual int32_t start( const void *licenseCert_ptr, size_t licenseCert_len, IAttestationBuilder &attestationBuilder) = 0;
    virtual int32_t getWarmUpStatus( void *warmUpStatus_ptr, size_t warmUpStatus_len, size_t *warmUpStatus_lenout) = 0;
    virtual int32_t warmUp( uint64_t options_val, uint64_t timeout_val, const ProxyBase &callback) = 0;
    
  protected:
    static const ObjectOp OP_start = 0;
    static const ObjectOp OP_getWarmUpStatus = 1;
    static const ObjectOp OP_warmUp = 2;
      
};

class IDeviceAttestation : public IIDeviceAttestation, public ProxyBase {
  public:
    IDeviceAttestation() {}
    IDeviceAttestation(Object impl) : ProxyBase(impl) {}
    virtual ~IDeviceAttestation() {}

    
/*
*
*   Starts creating an attestation.
*
*   @param[in]  licenseCert           Buffer containing license certificate.
*   @param[out] attestationBuilder    \link IAttestationBuilder \endlink object to construct an attestation.
*
*   @detdesc The license certificate must chain up to a license root to encrypt the attestation.
*
*   @return
*   Object_OK on success.
* 
*/
    virtual int32_t start( const void *licenseCert_ptr, size_t licenseCert_len, IAttestationBuilder &attestationBuilder) {
        ObjectArg a[] = {
            {.bi = (ObjectBufIn) { licenseCert_ptr, licenseCert_len * sizeof(uint8_t) } },
            {.o = (Object) { NULL, NULL } },
        };
            
        int32_t result = invoke(OP_start, a, ObjectCounts_pack(1, 0, 0, 1));
        if (Object_OK != result) { return result; }
        attestationBuilder.consume(a[1].o);
        
        return result;
    }
    
/*
*
*   Returns CBOR that shows the last time warming up completed for each individual optional
*   data requested by the client.
*
*   @param[out] warmUpStatus    Buffer containing warmup completion timestamps in CBOR format.
*
*   @return
*   Object_OK on success.
* 
*/
    virtual int32_t getWarmUpStatus( void *warmUpStatus_ptr, size_t warmUpStatus_len, size_t *warmUpStatus_lenout) {
        ObjectArg a[] = {
            {.b = (ObjectBuf) { warmUpStatus_ptr, warmUpStatus_len * sizeof(uint8_t) } },
        };
            
        int32_t result = invoke(OP_getWarmUpStatus, a, ObjectCounts_pack(0, 1, 0, 0));
        if (Object_OK != result) { return result; }
        *warmUpStatus_lenout = a[0].b.size / sizeof(uint8_t);
        
        return result;
    }
    
/*
*
*   Pokes at all necessary entities to prepare the relevant data, and initiates any other
*   warmup activity that might be applicable to the passed options.
*
*   @param[in] options     Options for the warmup.
*   @param[in] timeout     Time limit for the warmup to complete.
*   @param[in] callback    IDAWarmupCallback object to call when the warmup is done.
*
*   @return
*   Object_OK on success.
* 
*/
    virtual int32_t warmUp( uint64_t options_val, uint64_t timeout_val, const ProxyBase &callback) {
        struct bi {
            uint64_t m_options;
            uint64_t m_timeout;
        } i;
        i.m_options = options_val;
        i.m_timeout = timeout_val;
        
        ObjectArg a[] = {
            {.b = (ObjectBuf) { &i, 16 } },
            {.o = callback.get() },
        };
            
        int32_t result = invoke(OP_warmUp, a, ObjectCounts_pack(1, 0, 1, 0));
        if (Object_OK != result) { return result; }
        
        return result;
    }
    
};

